#include <WiFi.h>
#include <WebServer.h>
#include <vector>
#include <map>
#include <algorithm> // Für std::remove_if

// WLAN Parameter
const char* ssid = "FRITZ!Box 7590 RI";
const char* password = "52261156805385776967";

const int mqttPort = 1883;
WiFiServer mqttServer(mqttPort);
WebServer web(80);

struct Message {
  String topic;
  String payload;
};

struct MQTTClientState {
    WiFiClient client;
    String clientId;
    unsigned long lastSeen;
    String willTopic;
    String willMessage;
    bool hasLWT;
    bool connectedACKSent = false;
    std::vector<String> subscribedTopics;
};

// Die globale Liste aller verbundenen MQTT-Clients
std::vector<MQTTClientState> connectedMQTTClients;

// Die Struktur für Abonnements, die jetzt auf MQTTClientState zeigt
struct ActiveSubscription {
    MQTTClientState* clientState; // Pointer to the active client state
    String topicFilter; // The topic filter subscribed to
};
std::vector<ActiveSubscription> activeSubscriptions;

// ===========================================
// Ende der neu angeordneten Strukturen
// ===========================================


std::map<String, String> retainedMessages;
std::vector<Message> messageLog;    // Für Webinterface (Jetzt ist Message bekannt!)

// ... Rest des Codes bleibt wie zuvor ...

// Hilfsfunktion: Warte auf bestimmte Anzahl Bytes im Client
bool waitForBytes(WiFiClient& client, int length, unsigned long timeout = 1000) {
  unsigned long start = millis();
  while (client.available() < length) {
    if (millis() - start > timeout) return false;
    delay(1);
  }
  return true;
}

// Hilfsfunktion: Zerlegt ein Topic in seine Segmente
std::vector<String> splitTopic(const String& topic) {
  std::vector<String> parts;
  int start = 0;
  int idx = topic.indexOf('/', start);
  while (idx != -1) {
    parts.push_back(topic.substring(start, idx));
    start = idx + 1;
    idx = topic.indexOf('/', start);
  }
  parts.push_back(topic.substring(start));
  return parts;
}

// Hilfsfunktion: Überprüft, ob ein Topic mit einem Filter übereinstimmt (für Wildcards)
bool topicMatches(const String& topic, const String& filter) {
  if (filter == "#") return true; // Matches anything

  std::vector<String> topicParts = splitTopic(topic);
  std::vector<String> filterParts = splitTopic(filter);

  // Special case for '#' at the end
  if (!filterParts.empty() && filterParts.back() == "#") {
    if (topicParts.size() >= filterParts.size() - 1) {
      for (size_t i = 0; i < filterParts.size() - 1; ++i) {
        if (filterParts[i] == "+") continue;
        if (topicParts[i] != filterParts[i]) return false;
      }
      return true;
    } else {
      return false; // "#" only matches if there are enough levels
    }
  }

  // Exact match or '+' wildcard
  if (topicParts.size() != filterParts.size()) return false;

  for (size_t i = 0; i < topicParts.size(); ++i) {
    if (filterParts[i] == "+") continue;
    if (topicParts[i] != filterParts[i]) return false;
  }
  return true;
}

// Webinterface HTML Seite
void handleRoot() {
  String html = "<!DOCTYPE html><html><head><meta charset='utf-8'><title>ESP32 MQTT Broker</title>";
  html += "<style>body{font-family:Arial;margin:20px;}table{border-collapse:collapse;width:100%;}";
  html += "th,td{border:1px solid #ccc;padding:8px;text-align:left;}</style></head><body>";
  html += "<h1>MQTT Nachrichten Log</h1>";
  html += "<table><tr><th>Topic</th><th>Payload</th></tr>";

  for (auto &msg : messageLog) {
    html += "<tr><td>" + msg.topic + "</td><td>" + msg.payload + "</td></tr>";
  }
  html += "</table>";

  html += "<h2>Retained Messages</h2><table><tr><th>Topic</th><th>Payload</th></tr>";
  for (auto const& [topic, payload] : retainedMessages) {
      html += "<tr><td>" + topic + "</td><td>" + payload + "</td></tr>";
  }
  html += "</table>";

  html += "<h2>Connected MQTT Clients</h2><table><tr><th>Client ID</th><th>Last Seen (ms)</th><th>Subscribed Topics</th></tr>";
  for (auto &clientState : connectedMQTTClients) {
      html += "<tr><td>" + clientState.clientId + "</td><td>" + String(millis() - clientState.lastSeen) + " ago</td><td>";
      for (const String& topic : clientState.subscribedTopics) {
          html += topic + "<br>";
      }
      html += "</td></tr>";
  }
  html += "</table>";

/*
  html += "<h2>WLAN Netzwerke in der Nähe</h2><ul>";

  int n = WiFi.scanComplete();
  if (n == -2) {
    WiFi.scanNetworks(true);    // Starte Scan neu
    html += "<li>Scan läuft...</li>";
  } else if (n == 0) {
    html += "<li>Keine Netzwerke gefunden</li>";
  } else if (n > 0) {
    for (int i = 0; i < n; ++i) {
      html += "<li>" + WiFi.SSID(i) + " (RSSI: " + String(WiFi.RSSI(i)) + " dBm)</li>";
    }
    WiFi.scanDelete();
    // WiFi.scanNetworks(true); // Nicht jedes Mal neu scannen
  }

  html += "</ul>";
*/
  html += "<p>Verbunden mit: " + String(ssid) + "<br>IP-Adresse: " + WiFi.localIP().toString() + "</p>";
  html += "</body></html>";

  web.send(200, "text/html", html);
}

void setupWebInterface() {
  web.on("/", handleRoot);
  web.begin();
}

void setup() {
  Serial.begin(115200);
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  Serial.print("Verbinde mit WLAN");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println();
  Serial.println("Verbunden mit WLAN!");
  Serial.print("IP-Adresse: ");
  Serial.println(WiFi.localIP());

  Serial.println("Scanne nach WLANs in der Nähe...");
  int n = WiFi.scanNetworks();
  if (n == 0) {
    Serial.println("Keine Netzwerke gefunden.");
  } else {
    for (int i = 0; i < n; ++i) {
      Serial.print(i + 1);
      Serial.print(": ");
      Serial.print(WiFi.SSID(i));
      Serial.print(" (RSSI: ");
      Serial.print(WiFi.RSSI(i));
      Serial.println(" dBm)");
    }
  }

  mqttServer.begin();
  Serial.printf("MQTT Broker läuft auf Port %d\n", mqttPort);

  setupWebInterface();
}

// Funktion zum Senden von MQTT Publish Paketen an Client
void sendPublish(WiFiClient &client, const String &topic, const String &payload, uint8_t qos = 0, bool retain = false, uint16_t packetId = 0) {
  if (!client.connected()) {
      Serial.println("Error: Tried to send PUBLISH to disconnected client.");
      return;
  }

  int len = topic.length();
  int payloadLen = payload.length();

  // Fixed header: Packet Type (PUBLISH) + Flags (QoS, Retain)
  uint8_t fixedHeader = 0x30; // PUBLISH (0b0011)
  fixedHeader |= (qos << 1);  // QoS bits
  if (retain) fixedHeader |= 0x01; // Retain bit

  // Remaining length calculation
  int remLen = 2 + len + payloadLen; // 2 bytes for topic length, topic, payload
  if (qos > 0) {
      remLen += 2; // 2 bytes for Packet Identifier
  }

  // Variable byte integer encoding for Remaining Length (up to 4 bytes)
  uint8_t encodedRemLen[4];
  int i = 0;
  do {
      uint8_t digit = remLen % 128;
      remLen /= 128;
      if (remLen > 0) {
          digit |= 0x80;
      }
      encodedRemLen[i++] = digit;
  } while (remLen > 0);

  client.write(fixedHeader);
  for (int j = 0; j < i; ++j) {
      client.write(encodedRemLen[j]);
  }

  // Topic length MSB + LSB
  client.write((len >> 8) & 0xFF);
  client.write(len & 0xFF);

  // Topic
  client.print(topic);

  // Packet Identifier (if QoS > 0)
  if (qos > 0) {
      client.write((packetId >> 8) & 0xFF);
      client.write(packetId & 0xFF);
  }

  // Payload
  client.print(payload);
}

// Funktion zum Verarbeiten einer eingehenden PUBLISH-Nachricht
void handlePublish(MQTTClientState& clientState, byte header, byte remainingLength) {
  WiFiClient& client = clientState.client; // Get client reference from state
  uint8_t qos = (header >> 1) & 0x03; // Bits 1 and 2
  bool retain = (header & 0x01);     // Bit 0

  if (!waitForBytes(client, remainingLength)) {
    Serial.println("Timeout bei PUBLISH Payload");
    return;
  }

  byte topicLenMsb = client.read();
  byte topicLenLsb = client.read();
  int topicLen = (topicLenMsb << 8) | topicLenLsb;

  char topicChar[topicLen + 1];
  for (int i = 0; i < topicLen; i++) {
    topicChar[i] = client.read();
  }
  topicChar[topicLen] = 0;
  String topic = String(topicChar);

  uint16_t packetId = 0;
  if (qos > 0) {
      byte packetIdMsb = client.read();
      byte packetIdLsb = client.read();
      packetId = (packetIdMsb << 8) | packetIdLsb;
  }

  // Remaining bytes are payload
  int payloadLen = remainingLength - (2 + topicLen);
  if (qos > 0) payloadLen -= 2; // Account for Packet Identifier if QoS > 0

  // Read payload
  String payload = "";
  if (payloadLen > 0) {
      char payloadChar[payloadLen + 1];
      for (int i = 0; i < payloadLen; i++) {
        payloadChar[i] = client.read();
      }
      payloadChar[payloadLen] = 0;
      payload = String(payloadChar);
  }


  Serial.printf("PUBLISH empfangen: Topic='%s', Payload='%s', QoS=%d, Retain=%d\n", topic.c_str(), payload.c_str(), qos, retain);

  // Log message for web interface
  Message msg = {topic, payload};
  messageLog.push_back(msg);
  if (messageLog.size() > 50) { // Keep log size reasonable
      messageLog.erase(messageLog.begin());
  }

  // Handle Retained Messages
  if (retain) {
      if (payload.length() == 0) {
          retainedMessages.erase(topic); // Clear retained message if payload is empty
          Serial.printf("Retained message for topic '%s' cleared.\n", topic.c_str());
      } else {
          retainedMessages[topic] = payload;
          Serial.printf("Retained message for topic '%s' updated.\n", topic.c_str());
      }
  }

  // Forward to subscribers
  // Iterate through all currently active subscribers
  for (auto &sub : activeSubscriptions) {
    if (sub.clientState->client.connected() && topicMatches(topic, sub.topicFilter)) {
      Serial.printf("Weiterleiten an Subscriber '%s' für Topic: %s\n", sub.clientState->clientId.c_str(), sub.topicFilter.c_str());
      // Hier könnte man QoS des Abonnements beachten, senden wir vorerst mit QoS 0
      sendPublish(sub.clientState->client, topic, payload, 0, retain);
    }
  }

  // Send PUBACK for QoS 1
  if (qos == 1) {
      byte puback[] = {0x40, 0x02, (byte)(packetId >> 8), (byte)(packetId & 0xFF)};
      client.write(puback, sizeof(puback));
      Serial.printf("PUBACK gesendet für Packet ID %d\n", packetId);
  }
  // TODO: Handle QoS 2 (PUBREC, PUBREL, PUBCOMP)
}

void handleSubscribe(MQTTClientState& clientState, byte header, byte remainingLength) {
    WiFiClient& client = clientState.client; // Get client reference from state

    if (!waitForBytes(client, remainingLength)) {
        Serial.println("Timeout bei SUBSCRIBE Payload");
        return;
    }

    byte packetIdMsb = client.read();
    byte packetIdLsb = client.read();
    int packetId = (packetIdMsb << 8) | packetIdLsb;

    // Könnte mehrere Topics enthalten, hier nur das erste behandeln
    byte topicLenMsb = client.read();
    byte topicLenLsb = client.read();
    int topicLen = (topicLenMsb << 8) | topicLenLsb;

    char topicChar[topicLen + 1];
    for (int i = 0; i < topicLen; i++) {
        topicChar[i] = client.read();
    }
    topicChar[topicLen] = 0;
    String topic = String(topicChar);

    byte qos = client.read(); // Requested QoS

    Serial.printf("Client '%s' SUBSCRIBEd to Topic: %s with QoS %d\n", clientState.clientId.c_str(), topic.c_str(), qos);

    // Antwort: SUBACK
    byte suback[] = {0x90, 0x03, packetIdMsb, packetIdLsb, qos}; // Return granted QoS (here, same as requested)
    client.write(suback, sizeof(suback));
    Serial.println("SUBACK gesendet");

    // Add to active subscriptions and client's own subscribed topics
    ActiveSubscription newSub;
    newSub.clientState = &clientState;
    newSub.topicFilter = topic;
    activeSubscriptions.push_back(newSub);
    clientState.subscribedTopics.push_back(topic);

    // Send retained messages to new subscriber
    for (auto const& [retainedTopic, retainedPayload] : retainedMessages) {
        if (topicMatches(retainedTopic, topic)) {
            Serial.printf("Sende Retained Message für Topic '%s' an neuen Subscriber '%s'.\n", retainedTopic.c_str(), clientState.clientId.c_str());
            sendPublish(client, retainedTopic, retainedPayload, 0, true); // QoS 0 for simplicity
        }
    }
}

void handlePingReq(MQTTClientState& clientState) {
    WiFiClient& client = clientState.client; // Get client reference from state
    byte pingresp[] = {0xD0, 0x00};
    client.write(pingresp, sizeof(pingresp));
    Serial.printf("PINGRESP gesendet an Client '%s'\n", clientState.clientId.c_str());
    clientState.lastSeen = millis(); // Update lastSeen for the client
}


// Neue Funktion: Verarbeitet Daten von einem einzelnen Client nicht-blockierend
void processMQTTClient(MQTTClientState& clientState) {
    WiFiClient& client = clientState.client;

    if (!client.connected()) {
        return; // Client ist bereits getrennt, wird später aus der Liste entfernt
    }

    clientState.lastSeen = millis(); // Update last seen for active clients

    if (!clientState.connectedACKSent) {
        // This client has just connected and we need to process its CONNECT packet
        if (!waitForBytes(client, 2)) {
            // Still waiting for header, or timeout. Keep connection open for now.
            return;
        }

        byte header = client.read();
        byte remainingLength = client.read();

        if (header != 0x10) { // Not a CONNECT packet as expected
            Serial.printf("Client '%s' sent non-CONNECT first: 0x%X. Disconnecting.\n", clientState.clientId.c_str(), header);
            client.stop();
            return;
        }

        if (!waitForBytes(client, remainingLength)) {
            Serial.printf("Timeout processing CONNECT payload for client '%s'. Disconnecting.\n", clientState.clientId.c_str());
            client.stop();
            return;
        }

        // Parse CONNECT packet (simplified, similar to your original handleClient)
        for (int i = 0; i < 8; ++i) client.read(); // Skip protocol name, level, flags, keep alive

        byte clientIdLenHi = client.read();
        byte clientIdLenLo = client.read();
        int clientIdLen = (clientIdLenHi << 8) | clientIdLenLo;

        char clientId[clientIdLen + 1];
        for (int i = 0; i < clientIdLen; i++) {
            clientId[i] = client.read();
        }
        clientId[clientIdLen] = 0;
        clientState.clientId = String(clientId);

        Serial.printf("Client '%s' CONNECTED. Sending CONNACK.\n", clientState.clientId.c_str());

        // CONNACK
        byte connack[] = {0x20, 0x02, 0x00, 0x00}; // Session Present = 0, Connect Acknowledge = Accepted
        client.write(connack, sizeof(connack));
        clientState.connectedACKSent = true; // Mark as acknowledged
    }

    // Process other MQTT packets for this connected client
    if (client.available() >= 2) {
      byte h = client.read();
      byte len = client.read();

      int packetType = h >> 4;

      switch (packetType) {
        case 3: // PUBLISH
          handlePublish(clientState, h, len); // Pass clientState by reference
          break;
        case 8: // SUBSCRIBE
          handleSubscribe(clientState, h, len); // Pass clientState by reference
          break;
        case 12: // PINGREQ
            handlePingReq(clientState); // Pass clientState by reference
            break;
        case 14: // DISCONNECT
            Serial.printf("Client '%s' DISCONNECT requested. Closing connection.\n", clientState.clientId.c_str());
            client.stop(); // Gracefully stop
            break;
        default:
          Serial.printf("Client '%s': Unknown packet type 0x%X, length %d. Disconnecting.\n", clientState.clientId.c_str(), packetType, len);
          for (int i = 0; i < len && client.available(); ++i) client.read(); // Consume bytes
          client.stop();
          break;
      }
    }
}


void loop() {
  // 1. Webserver Anfragen verarbeiten (nicht blockierend)
  web.handleClient();

  // 2. Neue MQTT-Client Verbindungen akzeptieren
  WiFiClient newClient = mqttServer.available();
  if (newClient) {
    Serial.println("Neue TCP-Verbindung erkannt.");
    MQTTClientState newState;
    newState.client = newClient; // WiFiClient ist kopierbar in diesem Kontext (shallow copy)
    newState.lastSeen = millis();
    // connectedACKSent ist standardmäßig false
    connectedMQTTClients.push_back(newState);
    Serial.printf("Anzahl verbundener MQTT-Clients: %d\n", connectedMQTTClients.size());
  }

  // 3. Bestehende MQTT-Client-Verbindungen verarbeiten
  // Iteriere rückwärts, um sichere Entfernung zu ermöglichen
  for (int i = connectedMQTTClients.size() - 1; i >= 0; --i) {
    if (connectedMQTTClients[i].client.connected()) {
      processMQTTClient(connectedMQTTClients[i]);
    } else {
      // Client hat die Verbindung getrennt, entferne ihn
      Serial.printf("Client '%s' (%s) hat die Verbindung getrennt. Entferne ihn.\n",
                     connectedMQTTClients[i].clientId.c_str(),
                     connectedMQTTClients[i].client.remoteIP().toString().c_str());

      // Remove subscriptions for this client
      activeSubscriptions.erase(std::remove_if(activeSubscriptions.begin(), activeSubscriptions.end(),
                                             [&](const ActiveSubscription& sub) {
                                                 return sub.clientState == &connectedMQTTClients[i];
                                             }),
                                activeSubscriptions.end());

      connectedMQTTClients.erase(connectedMQTTClients.begin() + i);
    }
  }

  // 4. Keep-Alive / Timeout Prüfungen (Optional, aber empfohlen)
  // Dies müsste eine separate Funktion sein, die über alle clients iteriert
  // und prüft, ob lastSeen + keepAliveTimeout überschritten wurde.
  // if (millis() - clientState.lastSeen > KEEP_ALIVE_TIMEOUT) { client.stop(); }
}