// =================================================================================================
// ESP32 MQTT Broker mit integriertem Webinterface und AJAX-Datenaktualisierung
// =================================================================================================
// Dieses Programm verwandelt einen ESP32 in einen einfachen MQTT-Broker, der es IoT-Geräten
// ermöglicht, über das MQTT-Protokoll zu kommunizieren. Zusätzlich bietet es ein Webinterface,
// das den Status des Brokers, empfangene Nachrichten und verbundene Clients in Echtzeit anzeigt.
// Die Datenaktualisierung im Webinterface erfolgt dynamisch über AJAX.
//
// Bibliotheken:
// - WiFi.h: Für die WLAN-Konnektivität des ESP32.
// - WebServer.h: Zum Erstellen eines HTTP-Webservers auf dem ESP32.
// - vector: Für dynamische Arrays (z.B. Client-Listen, Topic-Teile).
// - map: Für Key-Value-Paare (z.B. Retained Messages).
// - algorithm: Für Algorithmen wie std::remove_if zum Entfernen von Elementen aus Vektoren.
// - ArduinoJson.h: Zum Serialisieren von Daten in das JSON-Format für das Webinterface.
//
// Hinweis: Die ArduinoJson-Bibliothek muss über den Bibliotheksmanager der Arduino IDE
//          installiert werden (Suchen Sie nach "ArduinoJson").
// =================================================================================================

#include <WiFi.h>          // Ermöglicht WLAN-Funktionen auf dem ESP32
#include <WebServer.h>     // Stellt Funktionen für einen HTTP-Webserver bereit
#include <vector>          // Standard C++ Bibliothek für dynamische Arrays (Vektoren)
#include <map>             // Standard C++ Bibliothek für assoziative Arrays (Maps/Dictionaries)
#include <algorithm>       // Standard C++ Bibliothek für nützliche Algorithmen (z.B. std::remove_if)
#include <ArduinoJson.h>   // Bibliothek zum einfachen Erstellen und Parsen von JSON-Daten

// =================================================================================================
// WLAN-Konfiguration
// =================================================================================================
const char* ssid = "FRITZ!Box 7590 RI";     // Ihr WLAN-Netzwerkname (SSID)
const char* password = "52261156805385776967"; // Ihr WLAN-Passwort

// =================================================================================================
// Server-Instanzen
// =================================================================================================
const int mqttPort = 1883;         // Standard-Port für unverschlüsselte MQTT-Kommunikation
WiFiServer mqttServer(mqttPort);   // Instanz des MQTT-Servers, lauscht auf eingehende MQTT-Verbindungen
WebServer web(80);                 // Instanz des Webservers, lauscht auf HTTP-Anfragen auf Port 80

// =================================================================================================
// Datenstrukturen
// =================================================================================================

/**
 * @brief Struktur zur Speicherung einer einzelnen MQTT-Nachricht.
 * Wird für das Nachrichten-Log im Webinterface verwendet.
 */
struct Message {
    String topic;          // Das Topic der Nachricht (z.B. "sensor/temperatur")
    String payload;        // Der Inhalt der Nachricht (z.B. "22.5")
    unsigned long timestamp; // Der Zeitpunkt, zu dem die Nachricht empfangen wurde (in Millisekunden seit Start)
};

/**
 * @brief Struktur zur Speicherung des Zustands eines einzelnen verbundenen MQTT-Clients.
 * Enthält alle relevanten Informationen über den Client.
 */
struct MQTTClientState {
    WiFiClient client;         // Die zugrunde liegende WiFiClient-Verbindung zum Client
    String clientId;           // Die eindeutige ID des MQTT-Clients
    unsigned long lastSeen;    // Der Zeitpunkt der letzten Aktivität des Clients (für Keep-Alive-Prüfungen)
    String willTopic;          // Das Topic für die Last Will and Testament (LWT) Nachricht (noch nicht vollständig implementiert)
    String willMessage;        // Die LWT-Nachricht (noch nicht vollständig implementiert)
    bool hasLWT;               // Flag, ob der Client eine LWT-Nachricht konfiguriert hat
    bool connectedACKSent = false; // Flag, ob das CONNACK-Paket an den Client gesendet wurde
    std::vector<String> subscribedTopics; // Eine Liste der Topics, die dieser Client abonniert hat
};

// Die globale Liste aller aktuell verbundenen MQTT-Clients
// Jeder Eintrag repräsentiert eine aktive MQTT-Sitzung.
std::vector<MQTTClientState> connectedMQTTClients;

/**
 * @brief Struktur zur Speicherung eines aktiven Abonnements.
 * Verknüpft einen Client mit einem abonnierten Topic-Filter.
 */
struct ActiveSubscription {
    MQTTClientState* clientState; // Pointer auf den Zustand des abonnierenden Clients
    String topicFilter;           // Der Topic-Filter, den der Client abonniert hat (kann Wildcards enthalten)
};
// Die globale Liste aller aktiven Abonnements
std::vector<ActiveSubscription> activeSubscriptions;

// Eine Map zur Speicherung von Retained Messages.
// Schlüssel ist das Topic, Wert ist die Payload.
std::map<String, String> retainedMessages;

// Ein Vektor, der die letzten empfangenen MQTT-Nachrichten für das Webinterface speichert.
std::vector<Message> messageLog;

// =================================================================================================
// Hilfsfunktionen
// =================================================================================================

/**
 * @brief Wartet, bis eine bestimmte Anzahl von Bytes im WiFiClient verfügbar ist, oder bis ein Timeout eintritt.
 * @param client Die WiFiClient-Verbindung.
 * @param length Die Anzahl der zu erwartenden Bytes.
 * @param timeout Das maximale Wartezeit-Timeout in Millisekunden.
 * @return True, wenn die Bytes verfügbar sind, False bei Timeout.
 */
bool waitForBytes(WiFiClient& client, int length, unsigned long timeout) {
    unsigned long start = millis(); // Startzeitpunkt der Wartezeit
    // Schleife, solange nicht genügend Bytes verfügbar sind
    while (client.available() < length) {
        // Prüfen, ob das Timeout überschritten wurde
        if (millis() - start > timeout) return false;
        delay(1); // Kurze Pause, um andere Aufgaben zu ermöglichen (nicht-blockierend)
    }
    return true; // Genügend Bytes sind verfügbar
}

/**
 * @brief Zerlegt einen MQTT-Topic-String in einzelne Segmente basierend auf dem '/' Trennzeichen.
 * @param topic Der zu zerlegende Topic-String.
 * @return Ein Vektor von Strings, der die einzelnen Topic-Segmente enthält.
 */
std::vector<String> splitTopic(const String& topic) {
    std::vector<String> parts; // Vektor zum Speichern der Topic-Teile
    int start = 0;             // Startposition für das Substring
    int idx = topic.indexOf('/', start); // Finde das erste '/'

    // Schleife, solange '/' gefunden wird
    while (idx != -1) {
        parts.push_back(topic.substring(start, idx)); // Füge das Segment vor '/' hinzu
        start = idx + 1;                             // Setze Startposition nach '/'
        idx = topic.indexOf('/', start);             // Suche nächstes '/'
    }
    // Füge das letzte Segment hinzu (oder das gesamte Topic, wenn kein '/' vorhanden war)
    parts.push_back(topic.substring(start));
    return parts;
}

/**
 * @brief Überprüft, ob ein gegebenes Topic mit einem Topic-Filter (inkl. Wildcards # und +) übereinstimmt.
 * Implementiert die grundlegenden MQTT-Wildcard-Regeln.
 * @param topic Das zu prüfende Topic (z.B. "sensor/wohnzimmer/temperatur").
 * @param filter Der Topic-Filter (z.B. "sensor/+/temperatur" oder "sensor/#").
 * @return True, wenn das Topic dem Filter entspricht, False sonst.
 */
bool topicMatches(const String& topic, const String& filter) {
    // Spezialfall: '#' als einziger Filter matcht alles
    if (filter == "#") return true;

    std::vector<String> topicParts = splitTopic(topic);     // Zerlege Topic in Segmente
    std::vector<String> filterParts = splitTopic(filter);   // Zerlege Filter in Segmente

    // Spezialfall: '#' am Ende des Filters (Multi-Level Wildcard)
    // Beispiel: "a/b/#" matcht "a/b", "a/b/c", "a/b/c/d"
    if (!filterParts.empty() && filterParts.back() == "#") {
        // Das Topic muss mindestens so viele Ebenen wie der Filter vor '#' haben
        if (topicParts.size() >= filterParts.size() - 1) {
            // Vergleiche die Segmente vor dem '#'
            for (size_t i = 0; i < filterParts.size() - 1; ++i) {
                if (filterParts[i] == "+") continue; // '+' matcht eine einzelne Ebene
                if (topicParts[i] != filterParts[i]) return false; // Exakter Match erforderlich
            }
            return true; // Alle vorherigen Segmente stimmen überein
        } else {
            return false; // Nicht genügend Ebenen im Topic für den '#' Filter
        }
    }

    // Für exakte Matches oder '+' Wildcards: Anzahl der Ebenen muss übereinstimmen
    if (topicParts.size() != filterParts.size()) return false;

    // Vergleiche jedes Segment
    for (size_t i = 0; i < topicParts.size(); ++i) {
        if (filterParts[i] == "+") continue; // '+' matcht eine einzelne Ebene, überspringe Vergleich
        if (topicParts[i] != filterParts[i]) return false; // Segmente müssen exakt übereinstimmen
    }
    return true; // Alle Segmente stimmen überein oder sind Wildcards
}

// =================================================================================================
// Webserver-Handler (AJAX-Endpunkt)
// =================================================================================================

/**
 * @brief Handler für AJAX-Anfragen an den Pfad "/mqtt_data".
 * Sammelt alle relevanten MQTT-Broker-Daten (Nachrichtenlog, Retained Messages, verbundene Clients)
 * und sendet sie als JSON-Antwort an den anfragenden Webbrowser.
 */
void handleMqttData() {
    // Erstelle ein DynamicJsonDocument mit einer geschätzten Größe.
    // Die Größe muss ausreichend sein, um alle Daten zu speichern. Bei mehr Daten muss dieser Wert erhöht werden.
    DynamicJsonDocument doc(2048);

    // 1. MQTT Nachrichten-Log in JSON konvertieren
    JsonArray messagesArray = doc.createNestedArray("messageLog"); // Erstelle ein JSON-Array namens "messageLog"
    for (auto &msg : messageLog) {                               // Iteriere über alle Nachrichten im Log
        JsonObject msgObj = messagesArray.createNestedObject();  // Erstelle ein JSON-Objekt für jede Nachricht
        msgObj["topic"] = msg.topic;                             // Füge Topic hinzu
        msgObj["payload"] = msg.payload;                         // Füge Payload hinzu
        msgObj["timestamp"] = msg.timestamp;                     // Füge den Zeitstempel hinzu (Millis seit Start)
    }

    // 2. Retained Messages in JSON konvertieren
    JsonObject retainedObj = doc.createNestedObject("retainedMessages"); // Erstelle ein JSON-Objekt namens "retainedMessages"
    for (auto const& [topic, payload] : retainedMessages) {             // Iteriere über alle Retained Messages in der Map
        retainedObj[topic] = payload;                                    // Füge jedes Topic-Payload-Paar hinzu
    }

    // 3. Verbundene Clients in JSON konvertieren
    JsonArray clientsArray = doc.createNestedArray("connectedClients"); // Erstelle ein JSON-Array namens "connectedClients"
    for (auto &clientState : connectedMQTTClients) {                   // Iteriere über alle verbundenen Clients
        JsonObject clientObj = clientsArray.createNestedObject();      // Erstelle ein JSON-Objekt für jeden Client
        clientObj["id"] = clientState.clientId;                        // Füge Client ID hinzu
        clientObj["lastSeen"] = millis() - clientState.lastSeen;       // Berechne die Zeit seit der letzten Aktivität
        JsonArray subTopicsArray = clientObj.createNestedArray("subscribedTopics"); // Erstelle ein Array für abonnierte Topics
        for (const String& topic : clientState.subscribedTopics) {     // Füge jedes abonnierte Topic hinzu
            subTopicsArray.add(topic);
        }
    }

    // 4. WLAN-Informationen hinzufügen
    doc["wifi_ssid"] = String(ssid);         // Füge die konfigurierte WLAN-SSID hinzu
    doc["wifi_ip"] = WiFi.localIP().toString(); // Füge die aktuelle IP-Adresse des ESP32 hinzu

    String jsonResponse;                         // String zum Speichern der finalen JSON-Antwort
    serializeJson(doc, jsonResponse);            // Serialisiere das JSON-Dokument in den String

    // Sende die JSON-Antwort mit dem Content-Type "application/json"
    web.send(200, "application/json", jsonResponse);
}

// =================================================================================================
// Webserver-Handler (Root-Seite HTML)
// =================================================================================================

/**
 * @brief Handler für die Root-URL ("/") des Webservers.
 * Generiert die vollständige HTML-Seite für das Webinterface,
 * einschließlich eingebettetem CSS und JavaScript für die AJAX-Aktualisierung.
 */
void handleRoot() {
    String html = "<!DOCTYPE html><html><head><meta charset='utf-8'><title>ESP32 MQTT Broker</title>";
    // Eingebettetes CSS für grundlegendes Styling der Tabellen und des Body
    html += "<style>body{font-family:Arial;margin:20px;}table{border-collapse:collapse;width:100%;}";
    html += "th,td{border:1px solid #ccc;padding:8px;text-align:left;}</style>";
    html += "</head><body>";

    // HTML-Struktur für das Nachrichten-Log
    html += "<h1>MQTT Nachrichten Log</h1>";
    html += "<table id='messageLogTable'><thead><tr><th>Topic</th><th>Payload</th><th>Zuletzt empfangen</th></tr></thead><tbody></tbody></table>";

    // HTML-Struktur für Retained Messages
    html += "<h2>Retained Messages</h2><table id='retainedMessagesTable'><thead><tr><th>Topic</th><th>Payload</th></tr></thead><tbody></tbody></table>";

    // HTML-Struktur für verbundene MQTT-Clients
    html += "<h2>Connected MQTT Clients</h2><table id='connectedClientsTable'><thead><tr><th>Client ID</th><th>Last Seen (ms)</th><th>Subscribed Topics</th></tr></thead><tbody></tbody></table>";

    // HTML-Struktur für WLAN-Informationen
    html += "<p>Verbunden mit: <span id='wifiSsid'></span><br>IP-Adresse: <span id='wifiIp'></span></p>";

    // =============================================================================================
    // Eingebettetes JavaScript für AJAX-Datenaktualisierung
    // =============================================================================================
    html += "<script>";
    html += "function fetchData() {"; // Funktion zum Abrufen und Anzeigen der Daten
    html += "    var xhr = new XMLHttpRequest();"; // Erstelle ein neues XMLHttpRequest-Objekt (für AJAX)
    html += "    xhr.onreadystatechange = function() {"; // Definiere den Event-Handler für Statusänderungen
    html += "        // Prüfe, ob die Anfrage abgeschlossen (readyState 4) und erfolgreich (status 200) war";
    html += "        if (xhr.readyState == 4 && xhr.status == 200) {";
    html += "            var data = JSON.parse(xhr.responseText);"; // Parse die empfangene JSON-Antwort

    // --- Aktualisierung des Nachrichten-Logs ---
    html += "            var messageLogTableBody = document.getElementById('messageLogTable').getElementsByTagName('tbody')[0];";
    html += "            messageLogTableBody.innerHTML = '';"; // Leere den Tabellenkörper, um alte Daten zu entfernen
    html += "            data.messageLog.forEach(function(item) {"; // Iteriere über die empfangenen Nachrichten
    html += "                var row = messageLogTableBody.insertRow();"; // Füge eine neue Zeile hinzu
    html += "                row.insertCell(0).innerText = item.topic;"; // Füge Topic-Zelle hinzu
    html += "                row.insertCell(1).innerText = item.payload;"; // Füge Payload-Zelle hinzu
    // Füge Zeitstempel-Zelle hinzu und formatiere ihn in eine lesbare Uhrzeit
    html += "                row.insertCell(2).innerText = new Date(item.timestamp).toLocaleTimeString();";
    html += "            });";

    // --- Aktualisierung der Retained Messages ---
    html += "            var retainedMessagesTableBody = document.getElementById('retainedMessagesTable').getElementsByTagName('tbody')[0];";
    html += "            retainedMessagesTableBody.innerHTML = '';"; // Leere den Tabellenkörper
    html += "            for (var topic in data.retainedMessages) {"; // Iteriere über die Retained Messages
    html += "                if (data.retainedMessages.hasOwnProperty(topic)) {"; // Stelle sicher, dass es eine eigene Eigenschaft ist
    html += "                    var row = retainedMessagesTableBody.insertRow();"; // Füge neue Zeile hinzu
    html += "                    row.insertCell(0).innerText = topic;";             // Füge Topic hinzu
    html += "                    row.insertCell(1).innerText = data.retainedMessages[topic];"; // Füge Payload hinzu
    html += "                }";
    html += "            }";

    // --- Aktualisierung der verbundenen Clients ---
    html += "            var connectedClientsTableBody = document.getElementById('connectedClientsTable').getElementsByTagName('tbody')[0];";
    html += "            connectedClientsTableBody.innerHTML = '';"; // Leere den Tabellenkörper
    html += "            data.connectedClients.forEach(function(item) {"; // Iteriere über die verbundenen Clients
    html += "                var row = connectedClientsTableBody.insertRow();"; // Füge neue Zeile hinzu
    html += "                row.insertCell(0).innerText = item.id;";          // Füge Client ID hinzu
    html += "                row.insertCell(1).innerText = item.lastSeen + ' ms ago';"; // Füge letzte Aktivität hinzu
    html += "                var topicsCell = row.insertCell(2);";             // Zelle für abonnierte Topics
    html += "                item.subscribedTopics.forEach(function(topic) {";  // Iteriere über abonnierte Topics
    html += "                    topicsCell.innerHTML += topic + '<br>';";    // Füge jedes Topic mit Zeilenumbruch hinzu
    html += "                });";
    html += "            });";

    // --- Aktualisierung der WLAN-Informationen ---
    html += "            document.getElementById('wifiSsid').innerText = data.wifi_ssid;"; // Aktualisiere SSID
    html += "            document.getElementById('wifiIp').innerText = data.wifi_ip;";     // Aktualisiere IP-Adresse

    html += "        }"; // Ende des if (xhr.readyState == 4 && xhr.status == 200)
    html += "    };"; // Ende des onreadystatechange-Handlers
    html += "    xhr.open('GET', '/mqtt_data', true);"; // Konfiguriere die AJAX-Anfrage (GET-Methode, an /mqtt_data, asynchron)
    html += "    xhr.send();"; // Sende die AJAX-Anfrage
    html += "}";
    html += "setInterval(fetchData, 2000);"; // Ruft fetchData alle 2000 Millisekunden (2 Sekunden) auf
    html += "window.onload = fetchData;"; // Ruft fetchData einmalig beim Laden der Seite auf, um initiale Daten anzuzeigen
    html += "</script>";
    // =============================================================================================

    html += "</body></html>"; // Ende des HTML-Dokuments

    // Sende die generierte HTML-Seite an den Client
    web.send(200, "text/html", html);
}

// =================================================================================================
// Webserver-Setup
// =================================================================================================

/**
 * @brief Initialisiert den HTTP-Webserver.
 * Definiert die Routen und die entsprechenden Handler-Funktionen.
 */
void setupWebInterface() {
    web.on("/", handleRoot);           // Wenn der Browser die Root-URL anfragt, rufe handleRoot() auf
    web.on("/mqtt_data", handleMqttData); // Wenn der Browser /mqtt_data anfragt (AJAX), rufe handleMqttData() auf
    web.begin();                       // Starte den Webserver
    Serial.println("HTTP server gestartet"); // Debug-Ausgabe
}

// =================================================================================================
// Setup-Funktion (wird einmal beim Start des ESP32 ausgeführt)
// =================================================================================================

/**
 * @brief Die Setup-Funktion wird einmalig beim Start des ESP32 ausgeführt.
 * Sie initialisiert die serielle Kommunikation, verbindet sich mit dem WLAN,
 * scannt nach WLANs in der Nähe, startet den MQTT-Broker und den Webserver.
 */
void setup() {
    Serial.begin(115200); // Starte die serielle Kommunikation für Debug-Ausgaben
    WiFi.mode(WIFI_STA);  // Setze den WLAN-Modus auf Station (verbindet sich mit einem Access Point)
    WiFi.begin(ssid, password); // Versuche, sich mit dem konfigurierten WLAN zu verbinden
    Serial.print("Verbinde mit WLAN");
    // Warte, bis die WLAN-Verbindung hergestellt ist
    while (WiFi.status() != WL_CONNECTED) {
        delay(500); // Kurze Pause
        Serial.print("."); // Fortschrittsanzeige
    }
    Serial.println();
    Serial.println("Verbunden mit WLAN!");
    Serial.print("IP-Adresse: ");
    Serial.println(WiFi.localIP()); // Gib die zugewiesene IP-Adresse aus

    // Optional: Scanne nach WLANs in der Nähe und gib sie auf der seriellen Konsole aus
    Serial.println("Scanne nach WLANs in der Nähe...");
    int n = WiFi.scanNetworks(); // Führe einen WLAN-Scan durch
    if (n == 0) {
        Serial.println("Keine Netzwerke gefunden.");
    } else {
        for (int i = 0; i < n; ++i) {
            Serial.print(i + 1); Serial.print(": ");
            Serial.print(WiFi.SSID(i)); Serial.print(" (RSSI: ");
            Serial.print(WiFi.RSSI(i)); Serial.println(" dBm)");
        }
    }

    mqttServer.begin(); // Starte den MQTT-Server, der auf eingehende Client-Verbindungen wartet
    Serial.printf("MQTT Broker läuft auf Port %d\n", mqttPort); // Debug-Ausgabe

    setupWebInterface(); // Initialisiere und starte den HTTP-Webserver
}

// =================================================================================================
// MQTT-Paket-Handling-Funktionen
// =================================================================================================

/**
 * @brief Sendet ein MQTT PUBLISH-Paket an einen verbundenen Client.
 * Konstruiert das Paket gemäß dem MQTT-Protokoll und sendet es über die WiFiClient-Verbindung.
 * @param client Die WiFiClient-Verbindung, an die gesendet werden soll.
 * @param topic Das Topic der Nachricht.
 * @param payload Der Inhalt der Nachricht.
 * @param qos Die Quality of Service (0, 1 oder 2). Nur QoS 0/1 wird hier aktiv unterstützt.
 * @param retain Gibt an, ob die Nachricht als Retained Message gespeichert werden soll.
 * @param packetId Die Paket-ID (nur relevant für QoS > 0).
 */
void sendPublish(WiFiClient &client, const String &topic, const String &payload, uint8_t qos, bool retain, uint16_t packetId) {
    if (!client.connected()) {
        Serial.println("Error: Tried to send PUBLISH to disconnected client.");
        return;
    }

    int len = topic.length();       // Länge des Topics
    int payloadLen = payload.length(); // Länge der Payload

    // Fixed Header: Packet Type (PUBLISH = 0b0011) + Flags (DUP, QoS, RETAIN)
    uint8_t fixedHeader = 0x30; // PUBLISH (0b00110000)
    fixedHeader |= (qos << 1);  // Setze die QoS-Bits (Bit 1 und 2)
    if (retain) fixedHeader |= 0x01; // Setze das Retain-Bit (Bit 0), wenn retain true ist

    // Remaining Length Calculation (Variable Header + Payload)
    // 2 Bytes für Topic Length + Topic Length + Payload Length
    int remLen = 2 + len + payloadLen;
    if (qos > 0) {
        remLen += 2; // Bei QoS > 0 kommen 2 Bytes für die Packet Identifier hinzu
    }

    // Variable Byte Integer Encoding für Remaining Length (bis zu 4 Bytes)
    // Dies ist eine spezielle Kodierung im MQTT-Protokoll für die Länge des restlichen Pakets.
    uint8_t encodedRemLen[4];
    int i = 0;
    do {
        uint8_t digit = remLen % 128;
        remLen /= 128;
        if (remLen > 0) {
            digit |= 0x80; // Setze das Fortsetzungsbit, wenn weitere Bytes folgen
        }
        encodedRemLen[i++] = digit;
    } while (remLen > 0);

    // Sende den Fixed Header
    client.write(fixedHeader);
    // Sende die kodierte Remaining Length
    for (int j = 0; j < i; ++j) {
        client.write(encodedRemLen[j]);
    }

    // Variable Header: Topic Length (MSB + LSB)
    client.write((len >> 8) & 0xFF); // Most Significant Byte der Topic-Länge
    client.write(len & 0xFF);       // Least Significant Byte der Topic-Länge

    // Variable Header: Topic
    client.print(topic); // Sende den Topic-String

    // Variable Header: Packet Identifier (nur wenn QoS > 0)
    if (qos > 0) {
        client.write((packetId >> 8) & 0xFF); // MSB der Paket-ID
        client.write(packetId & 0xFF);       // LSB der Paket-ID
    }

    // Payload
    client.print(payload); // Sende die Payload
}

/**
 * @brief Verarbeitet ein eingehendes MQTT PUBLISH-Paket von einem Client.
 * Extrahiert Topic und Payload, loggt die Nachricht, behandelt Retained Messages
 * und leitet die Nachricht an abonnierte Clients weiter.
 * @param clientState Der Zustand des Clients, von dem das Paket empfangen wurde.
 * @param header Der Fixed Header des PUBLISH-Pakets.
 * @param remainingLength Die Remaining Length des PUBLISH-Pakets.
 */
void handlePublish(MQTTClientState& clientState, byte header, byte remainingLength) {
    WiFiClient& client = clientState.client; // Referenz auf die Client-Verbindung

    // Extrahiere QoS-Level und Retain-Flag aus dem Fixed Header
    uint8_t qos = (header >> 1) & 0x03; // Bits 1 und 2 (0b00000110)
    bool retain = (header & 0x01);      // Bit 0 (0b00000001)

    // Warte, bis die gesamte Payload verfügbar ist
    if (!waitForBytes(client, remainingLength)) {
        Serial.println("Timeout bei PUBLISH Payload");
        return;
    }

    // Lese Topic Length
    byte topicLenMsb = client.read();
    byte topicLenLsb = client.read();
    int topicLen = (topicLenMsb << 8) | topicLenLsb;

    // Lese Topic-String
    char topicChar[topicLen + 1]; // +1 für das Null-Terminierungszeichen
    for (int i = 0; i < topicLen; i++) {
        topicChar[i] = client.read();
    }
    topicChar[topicLen] = 0; // Null-Terminierung
    String topic = String(topicChar); // Konvertiere zu Arduino String

    uint16_t packetId = 0;
    // Lese Packet Identifier, falls QoS > 0
    if (qos > 0) {
        byte packetIdMsb = client.read();
        byte packetIdLsb = client.read();
        packetId = (packetIdMsb << 8) | packetIdLsb;
    }

    // Berechne die Länge der Payload
    int payloadLen = remainingLength - (2 + topicLen); // Gesamt-Restlänge - (2 Bytes Topic-Länge + Topic-Länge)
    if (qos > 0) payloadLen -= 2; // Wenn QoS > 0, ziehe 2 Bytes für die Packet ID ab

    // Lese Payload-String
    String payload = "";
    if (payloadLen > 0) {
        char payloadChar[payloadLen + 1];
        for (int i = 0; i < payloadLen; i++) {
            payloadChar[i] = client.read();
        }
        payloadChar[payloadLen] = 0; // Null-Terminierung
        payload = String(payloadChar); // Konvertiere zu Arduino String
    }

    // Debug-Ausgabe des empfangenen PUBLISH-Pakets
    Serial.printf("PUBLISH empfangen: Topic='%s', Payload='%s', QoS=%d, Retain=%d\n", topic.c_str(), payload.c_str(), qos, retain);

    // Logge die Nachricht für das Webinterface
    Message msg = {topic, payload, millis()}; // Erstelle eine Message-Struktur mit aktuellem Zeitstempel
    messageLog.push_back(msg); // Füge die Nachricht zum Log hinzu
    if (messageLog.size() > 50) { // Begrenze die Größe des Nachrichten-Logs auf 50 Einträge
        messageLog.erase(messageLog.begin()); // Entferne die älteste Nachricht, wenn das Limit überschritten wird
    }

    // Behandele Retained Messages
    if (retain) {
        if (payload.length() == 0) {
            // Wenn die Payload leer ist, lösche die Retained Message für dieses Topic
            retainedMessages.erase(topic);
            Serial.printf("Retained message for topic '%s' cleared.\n", topic.c_str());
        } else {
            // Speichere oder aktualisiere die Retained Message
            retainedMessages[topic] = payload;
            Serial.printf("Retained message for topic '%s' updated.\n", topic.c_str());
        }
    }

    // Leite die Nachricht an alle abonnierten Clients weiter
    for (auto &sub : activeSubscriptions) { // Iteriere über alle aktiven Abonnements
        // Prüfe, ob der abonnierende Client noch verbunden ist und ob das Topic matcht
        if (sub.clientState->client.connected() && topicMatches(topic, sub.topicFilter)) {
            Serial.printf("Weiterleiten an Subscriber '%s' für Topic: %s\n", sub.clientState->clientId.c_str(), sub.topicFilter.c_str());
            // Sende das PUBLISH-Paket an den Subscriber. Hier wird QoS 0 verwendet, um die Einfachheit zu wahren.
            sendPublish(sub.clientState->client, topic, payload, 0, retain);
        }
    }

    // Sende PUBACK (Publish Acknowledge) für QoS 1 Nachrichten
    if (qos == 1) {
        // PUBACK-Paket: Fixed Header (0x40), Remaining Length (0x02), Packet Identifier (MSB, LSB)
        byte puback[] = {0x40, 0x02, (byte)(packetId >> 8), (byte)(packetId & 0xFF)};
        client.write(puback, sizeof(puback)); // Sende das PUBACK-Paket
        Serial.printf("PUBACK gesendet für Packet ID %d\n", packetId); // Debug-Ausgabe
    }
    // TODO: Für eine vollständige MQTT-Implementierung müssten hier auch QoS 2 (PUBREC, PUBREL, PUBCOMP) behandelt werden.
}

/**
 * @brief Verarbeitet ein eingehendes MQTT SUBSCRIBE-Paket von einem Client.
 * Extrahiert den Topic-Filter, sendet eine SUBACK-Antwort und
 * fügt das Abonnement zur Liste der aktiven Abonnements hinzu.
 * Sendet auch Retained Messages an den neuen Subscriber.
 * @param clientState Der Zustand des Clients, von dem das Paket empfangen wurde.
 * @param header Der Fixed Header des SUBSCRIBE-Pakets.
 * @param remainingLength Die Remaining Length des SUBSCRIBE-Pakets.
 */
void handleSubscribe(MQTTClientState& clientState, byte header, byte remainingLength) {
    WiFiClient& client = clientState.client; // Referenz auf die Client-Verbindung

    // Warte, bis die gesamte Payload verfügbar ist
    if (!waitForBytes(client, remainingLength)) {
        Serial.println("Timeout bei SUBSCRIBE Payload");
        return;
    }

    // Lese Packet Identifier
    byte packetIdMsb = client.read();
    byte packetIdLsb = client.read();
    int packetId = (packetIdMsb << 8) | packetIdLsb;

    // Lese Topic Filter Length
    byte topicLenMsb = client.read();
    byte topicLenLsb = client.read();
    int topicLen = (topicLenMsb << 8) | topicLenLsb;

    // Lese Topic Filter String
    char topicChar[topicLen + 1];
    for (int i = 0; i < topicLen; i++) {
        topicChar[i] = client.read();
    }
    topicChar[topicLen] = 0;
    String topic = String(topicChar);

    // Lese Requested QoS (Quality of Service)
    byte qos = client.read();

    // Debug-Ausgabe des Abonnements
    Serial.printf("Client '%s' SUBSCRIBEd to Topic: %s with QoS %d\n", clientState.clientId.c_str(), topic.c_str(), qos);

    // Sende SUBACK (Subscribe Acknowledge) Antwort
    // SUBACK-Paket: Fixed Header (0x90), Remaining Length (0x03), Packet Identifier (MSB, LSB), Granted QoS
    byte suback[] = {0x90, 0x03, packetIdMsb, packetIdLsb, qos}; // Sende die angeforderte QoS als gewährte QoS zurück
    client.write(suback, sizeof(suback)); // Sende das SUBACK-Paket
    Serial.println("SUBACK gesendet"); // Debug-Ausgabe

    // Füge das neue Abonnement zur Liste der aktiven Abonnements hinzu
    ActiveSubscription newSub;
    newSub.clientState = &clientState; // Zeiger auf den Client-Zustand
    newSub.topicFilter = topic;        // Der abonnierte Topic-Filter
    activeSubscriptions.push_back(newSub);

    // Füge das abonnierte Topic auch zur Liste der abonnierten Topics des Clients hinzu (für Webinterface-Anzeige)
    clientState.subscribedTopics.push_back(topic);

    // Sende alle passenden Retained Messages an den neuen Subscriber
    for (auto const& [retainedTopic, retainedPayload] : retainedMessages) {
        if (topicMatches(retainedTopic, topic)) { // Prüfe, ob die Retained Message zum abonnierten Filter passt
            Serial.printf("Sende Retained Message für Topic '%s' an neuen Subscriber '%s'.\n", retainedTopic.c_str(), clientState.clientId.c_str());
            // Sende die Retained Message als PUBLISH-Paket (QoS 0, Retain-Flag true)
            sendPublish(client, retainedTopic, retainedPayload, 0, true);
        }
    }
}

/**
 * @brief Verarbeitet ein eingehendes MQTT PINGREQ-Paket von einem Client.
 * Antwortet mit einem PINGRESP-Paket, um die Verbindung aktiv zu halten.
 * @param clientState Der Zustand des Clients, von dem das Paket empfangen wurde.
 */
void handlePingReq(MQTTClientState& clientState) {
    WiFiClient& client = clientState.client; // Referenz auf die Client-Verbindung
    byte pingresp[] = {0xD0, 0x00};          // PINGRESP-Paket: Fixed Header (0xD0), Remaining Length (0x00)
    client.write(pingresp, sizeof(pingresp)); // Sende das PINGRESP-Paket
    Serial.printf("PINGRESP gesendet an Client '%s'\n", clientState.clientId.c_str()); // Debug-Ausgabe
    clientState.lastSeen = millis(); // Aktualisiere den "Last Seen"-Zeitstempel des Clients
}

/**
 * @brief Verarbeitet eingehende MQTT-Pakete von einem einzelnen Client nicht-blockierend.
 * Dies ist der zentrale Dispatcher für die MQTT-Kommunikation pro Client.
 * @param clientState Der Zustand des MQTT-Clients, dessen Daten verarbeitet werden sollen.
 */
void processMQTTClient(MQTTClientState& clientState) {
    WiFiClient& client = clientState.client; // Referenz auf die WiFiClient-Verbindung

    // Wenn der Client nicht mehr verbunden ist, beende die Funktion.
    // Er wird später aus der Liste der verbundenen Clients entfernt.
    if (!client.connected()) {
        return;
    }

    clientState.lastSeen = millis(); // Aktualisiere den "Last Seen"-Zeitstempel, da der Client aktiv ist

    // Wenn das CONNACK-Paket noch nicht an den Client gesendet wurde,
    // bedeutet dies, dass dies eine neue Verbindung ist, die ihr CONNECT-Paket sendet.
    if (!clientState.connectedACKSent) {
        // Warte auf die ersten 2 Bytes des CONNECT-Pakets (Fixed Header und Remaining Length)
        if (!waitForBytes(client, 2)) {
            // Wenn nicht genügend Bytes verfügbar sind, warte weiter.
            // Die Verbindung bleibt offen und wird im nächsten Loop-Durchlauf erneut geprüft.
            return;
        }

        byte header = client.read();        // Lese den Fixed Header
        byte remainingLength = client.read(); // Lese die Remaining Length

        // Prüfe, ob es sich um ein CONNECT-Paket handelt (Fixed Header sollte 0x10 sein)
        if (header != 0x10) {
            Serial.printf("Client '%s' sent non-CONNECT first: 0x%X. Disconnecting.\n", clientState.clientId.c_str(), header);
            client.stop(); // Wenn nicht, trenne die Verbindung
            return;
        }

        // Warte auf den Rest des CONNECT-Pakets (Payload)
        if (!waitForBytes(client, remainingLength)) {
            Serial.printf("Timeout processing CONNECT payload for client '%s'. Disconnecting.\n", clientState.clientId.c_str());
            client.stop(); // Bei Timeout trenne die Verbindung
            return;
        }

        // Überspringe die ersten 8 Bytes des CONNECT-Pakets (Protokollname, Level, Flags, Keep-Alive)
        for (int i = 0; i < 8; ++i) client.read();

        // Lese die Länge der Client-ID
        byte clientIdLenHi = client.read();
        byte clientIdLenLo = client.read();
        int clientIdLen = (clientIdLenHi << 8) | clientIdLenLo;

        // Lese die Client-ID
        char clientId[clientIdLen + 1]; // +1 für das Null-Terminierungszeichen
        for (int i = 0; i < clientIdLen; i++) {
            clientId[i] = client.read();
        }
        clientId[clientIdLen] = 0; // Null-Terminierung
        clientState.clientId = String(clientId); // Speichere die ID im Client-Zustand

        // --- DEBUG-AUSGABE: Überprüfung der Client-ID ---
        if (clientState.clientId.length() == 0) {
            Serial.printf("DEBUG: Client verbunden OHNE ID (Länge 0). Remote IP: %s\n", client.remoteIP().toString().c_str());
            // Optional: Hier könnte man eine automatische ID generieren, wenn der Client keine sendet.
            // clientState.clientId = "AutoGen_" + String(client.remoteIP()[3]) + "_" + String(millis() % 1000);
        } else {
            Serial.printf("DEBUG: Client '%s' verbunden MIT ID. Remote IP: %s\n", clientState.clientId.c_str(), client.remoteIP().toString().c_str());
        }
        // --- ENDE DEBUG-AUSGABE ---

        Serial.printf("Client '%s' CONNECTED. Sending CONNACK.\n", clientState.clientId.c_str());

        // Sende CONNACK-Paket (Connect Acknowledge)
        // Fixed Header (0x20), Remaining Length (0x02), Session Present (0x00), Connect Acknowledge Code (0x00 = Accepted)
        byte connack[] = {0x20, 0x02, 0x00, 0x00};
        client.write(connack, sizeof(connack)); // Sende das CONNACK
        clientState.connectedACKSent = true; // Markiere, dass CONNACK gesendet wurde
    }

    // Verarbeite andere MQTT-Pakete für diesen verbundenen Client
    // Prüfe, ob mindestens 2 Bytes (Fixed Header + Remaining Length) für ein neues Paket verfügbar sind
    if (client.available() >= 2) {
      byte h = client.read(); // Lese Fixed Header
      byte len = client.read(); // Lese Remaining Length

      int packetType = h >> 4; // Extrahiere den Pakettyp aus den oberen 4 Bits des Fixed Headers

      // Dispatcher: Rufe die entsprechende Handler-Funktion basierend auf dem Pakettyp auf
      switch (packetType) {
        case 3: // PUBLISH-Paket
          handlePublish(clientState, h, len); // Rufe den PUBLISH-Handler auf
          break;
        case 8: // SUBSCRIBE-Paket
          handleSubscribe(clientState, h, len); // Rufe den SUBSCRIBE-Handler auf
          break;
        case 12: // PINGREQ-Paket
            handlePingReq(clientState); // Rufe den PINGREQ-Handler auf
            break;
        case 14: // DISCONNECT-Paket
            Serial.printf("Client '%s' DISCONNECT requested. Closing connection.\n", clientState.clientId.c_str());
            client.stop(); // Schließe die Verbindung auf Wunsch des Clients
            break;
        default: // Unbekannter Pakettyp
          Serial.printf("Client '%s': Unknown packet type 0x%X, length %d. Disconnecting.\n", clientState.clientId.c_str(), packetType, len);
          // Versuche, die restlichen Bytes des unbekannten Pakets zu konsumieren, um den Stream zu bereinigen
          for (int i = 0; i < len && client.available(); ++i) client.read();
          client.stop(); // Trenne die Verbindung bei unbekanntem Pakettyp
          break;
      }
    }
}

// =================================================================================================
// Loop-Funktion (wird wiederholt ausgeführt)
// =================================================================================================

/**
 * @brief Die Haupt-Loop-Funktion des Programms.
 * Sie wird kontinuierlich wiederholt und ist für die nicht-blockierende Verarbeitung
 * aller Webserver-Anfragen, neuen MQTT-Client-Verbindungen und bestehenden
 * MQTT-Client-Kommunikationen zuständig.
 */
void loop() {
    // 1. Webserver-Anfragen verarbeiten
    // Diese Funktion muss regelmäßig aufgerufen werden, damit der Webserver
    // eingehende HTTP-Anfragen (z.B. für die HTML-Seite oder AJAX-Daten) verarbeiten kann.
    web.handleClient();

    // 2. Neue MQTT-Client-Verbindungen akzeptieren
    // Prüft, ob ein neuer MQTT-Client versucht, sich zu verbinden.
    WiFiClient newClient = mqttServer.available();
    if (newClient) {
        Serial.println("Neue TCP-Verbindung erkannt.");
        MQTTClientState newState; // Erstelle einen neuen Zustand für den Client
        newState.client = newClient; // Weise die neue WiFiClient-Verbindung zu
        newState.lastSeen = millis(); // Setze den "Last Seen"-Zeitstempel auf jetzt
        // connectedACKSent ist standardmäßig false, wird in processMQTTClient gesetzt
        connectedMQTTClients.push_back(newState); // Füge den neuen Client zur globalen Liste hinzu
        Serial.printf("Anzahl verbundener MQTT-Clients: %d\n", connectedMQTTClients.size()); // Debug-Ausgabe
    }

    // 3. Bestehende MQTT-Client-Verbindungen verarbeiten und getrennte Clients entfernen
    // Iteriere rückwärts durch die Liste der verbundenen Clients, um Clients sicher entfernen zu können,
    // ohne Probleme mit der Indexverschiebung zu bekommen.
    for (int i = connectedMQTTClients.size() - 1; i >= 0; --i) {
        // Prüfe, ob der Client noch verbunden ist
        if (connectedMQTTClients[i].client.connected()) {
            // Wenn ja, verarbeite seine ausstehenden MQTT-Pakete
            processMQTTClient(connectedMQTTClients[i]);
        } else {
            // Wenn der Client nicht mehr verbunden ist (z.B. DISCONNECT gesendet, Timeout, Netzwerkfehler)
            Serial.printf("Client '%s' (%s) hat die Verbindung getrennt. Entferne ihn.\n",
                            connectedMQTTClients[i].clientId.c_str(),
                            connectedMQTTClients[i].client.remoteIP().toString().c_str());

            // Entferne alle Abonnements, die mit diesem Client verknüpft sind
            // std::remove_if verschiebt alle Elemente, die die Bedingung erfüllen, ans Ende des Vektors
            // und gibt einen Iterator auf das erste dieser Elemente zurück.
            // .erase() entfernt dann den Bereich von diesem Iterator bis zum Ende des Vektors.
            activeSubscriptions.erase(std::remove_if(activeSubscriptions.begin(), activeSubscriptions.end(),
                                                     [&](const ActiveSubscription& sub) {
                                                         // Die Lambda-Funktion prüft, ob der Client-Pointer des Abonnements
                                                         // mit dem Pointer des zu entfernenden Clients übereinstimmt.
                                                         return sub.clientState == &connectedMQTTClients[i];
                                                     }),
                                     activeSubscriptions.end());

            // Entferne den getrennten Client aus der Liste der verbundenen Clients
            connectedMQTTClients.erase(connectedMQTTClients.begin() + i);
        }
    }

    // 4. Keep-Alive / Timeout Prüfungen (Optional, aber empfohlen für robusten Broker)
    // Dieser Teil ist hier noch nicht explizit implementiert, könnte aber hinzugefügt werden,
    // um Clients, die über ihre Keep-Alive-Zeit hinaus inaktiv sind, automatisch zu trennen.
    // Beispiel-Logik:
    // for (auto &clientState : connectedMQTTClients) {
    //     if (millis() - clientState.lastSeen > (clientState.keepAliveInterval * 1.5 * 1000)) { // 1.5x Keep-Alive als Toleranz
    //         clientState.client.stop(); // Verbindung trennen
    //         // LWT-Nachricht veröffentlichen, falls konfiguriert
    //     }
    // }
}